#include "Xoroshiro128Plus.isph"
#include "PrimitiveTypes/BitonicSort4.isph"
#include "Stack.isph"

inline void RandomBound4(uniform uint64* RandomVec, uniform uint64* Bound)
{
    uniform uint64 Even[2];

    {
        foreach (i = 0 ... 2)
        {
            Even[i] = (uint64)(RandomVec[i] & 0xFFFFFFFF) * (uint64)(Bound[i] & 0xFFFFFFFF);
        }
    }

    RightShift(Even, 32, 2);

    uniform uint64 Odd[2];
    RightShift(RandomVec, 32, 2);

    {
        foreach (i = 0 ... 2)
        {
            Odd[i] = (uint64)(RandomVec[i] & 0xFFFFFFFF) * (uint64)(Bound[i] & 0xFFFFFFFF);
        }
    }

    uniform int Mask[4] = {0, 1 + 4, 2, 3 + 4};
    uniform int32* Even4 = (uniform int32*)(&Even[0]);
    uniform int32* Odd4 = (uniform int32*)(&Odd[0]);
    uniform int32* RandomVec4 = (uniform int32*)(&RandomVec[0]);
    Shuffle4_Two_Vectors(int32, Even4, Odd4, RandomVec4, Mask);
}

/** 
 * sorting network for 4 int with compare-exchange macros
 * (used for pivot selection in median of the medians) 
 */
// inline void Sort_4(uniform Sort4Type Data[])
#define Sort_4(Data, Sort4Type, COEX_SHUFFLE_OP, ...) \
{ \
    uniform int Mask[4] = {1, 0, 3, 2}; \
    uniform int Mask1[4] = {0, 0 + 4, 2, 2 + 4}; \
    COEX_SHUFFLE((Data), Mask, Mask1, COEX_SHUFFLE_OP, Sort4Type, __VA_ARGS__); \
\
    uniform int Mask2[4] = {3, 2, 1, 0}; \
    uniform int Mask3[4] = {0, 1, 2 + 4, 3 + 4}; \
    COEX_SHUFFLE((Data), Mask2, Mask3, COEX_SHUFFLE_OP, Sort4Type, __VA_ARGS__); \
\
    COEX_SHUFFLE((Data), Mask, Mask1, COEX_SHUFFLE_OP, Sort4Type, __VA_ARGS__); \
}

#define GetPivot4(Sort4Type, Data, Left, Right, COEX_OP, COEX_SHUFFLE_OP, ...) \
{ \
    uniform uint32 Bound[4]; \
    foreach (i = 0 ... 4) \
    { \
        Bound[i] = Right - Left + 1; \
    } \
\
    uniform uint32 LeftVec[4]; \
    foreach (i = 0 ... 4) \
    { \
        LeftVec[i] = Left; \
    } \
\
    /* seeds for vectorized random number generator */ \
    uniform uint64 S0[2] = {16294208416658607535, 5197578548964807871}; \
    uniform uint64 S1[2] = {3746585686858627171, 1826112205991530872}; \
\
    foreach (i = 0 ... 2) \
    { \
        S0[i] = S0[i] + Left; \
    } \
\
    foreach (i = 0 ... 2) \
    { \
        S1[i] = S1[i] - Right; \
    } \
\
    uniform Sort4Type V[4 * 9]; \
    for (uniform int32 i = 0; i < 9; ++i) /* fill 9 vectors with random numbers */ \
    { \
        /* vector with 2 random uint64_t */ \
        uniform uint64 Result[2]; \
        Xoroshiro128Plus(S0, S1, Result, 2); \
\
        /* random numbers between 0 and bound - 1 */ \
        uniform uint64* Bound2 = (uniform uint64*)(&Bound[0]); \
        RandomBound4(Result, Bound2); \
\
        /* indices for arr */ \
        uniform uint32* Result4 = (uniform uint32*)(&Result[0]); \
        foreach (j = 0 ... 4) \
        { \
            Result4[j] = Result4[j] + LeftVec[j]; \
        } \
\
        uniform int32 StartIndex = i * 4; \
        foreach (j = 0 ... 4) \
        { \
            V[StartIndex + j] = Data[Result4[j]]; \
        } \
    } \
\
    /* median network for 9 elements */ \
    COEX(V + GetVectorIndex4(0), V + GetVectorIndex4(1), COEX_OP, Sort4Type, __VA_ARGS__); COEX(V + GetVectorIndex4(2), V + GetVectorIndex4(3), COEX_OP, Sort4Type, __VA_ARGS__); /* step 1 */ \
    COEX(V + GetVectorIndex4(4), V + GetVectorIndex4(5), COEX_OP, Sort4Type, __VA_ARGS__); COEX(V + GetVectorIndex4(6), V + GetVectorIndex4(7), COEX_OP, Sort4Type, __VA_ARGS__); \
    COEX(V + GetVectorIndex4(0), V + GetVectorIndex4(2), COEX_OP, Sort4Type, __VA_ARGS__); COEX(V + GetVectorIndex4(1), V + GetVectorIndex4(3), COEX_OP, Sort4Type, __VA_ARGS__); /* step 2 */ \
    COEX(V + GetVectorIndex4(4), V + GetVectorIndex4(6), COEX_OP, Sort4Type, __VA_ARGS__); COEX(V + GetVectorIndex4(5), V + GetVectorIndex4(7), COEX_OP, Sort4Type, __VA_ARGS__); \
    COEX(V + GetVectorIndex4(0), V + GetVectorIndex4(4), COEX_OP, Sort4Type, __VA_ARGS__); COEX(V + GetVectorIndex4(1), V + GetVectorIndex4(2), COEX_OP, Sort4Type, __VA_ARGS__); /* step 3 */ \
    COEX(V + GetVectorIndex4(5), V + GetVectorIndex4(6), COEX_OP, Sort4Type, __VA_ARGS__); COEX(V + GetVectorIndex4(3), V + GetVectorIndex4(7), COEX_OP, Sort4Type, __VA_ARGS__); \
    COEX(V + GetVectorIndex4(1), V + GetVectorIndex4(5), COEX_OP, Sort4Type, __VA_ARGS__); COEX(V + GetVectorIndex4(2), V + GetVectorIndex4(6), COEX_OP, Sort4Type, __VA_ARGS__); /* step 4 */ \
    COEX(V + GetVectorIndex4(3), V + GetVectorIndex4(5), COEX_OP, Sort4Type, __VA_ARGS__); COEX(V + GetVectorIndex4(2), V + GetVectorIndex4(4), COEX_OP, Sort4Type, __VA_ARGS__); /* step 5 */ \
    COEX(V + GetVectorIndex4(3), V + GetVectorIndex4(4), COEX_OP, Sort4Type, __VA_ARGS__); /* step 6 */ \
    COEX(V + GetVectorIndex4(3), V + GetVectorIndex4(8), COEX_OP, Sort4Type, __VA_ARGS__); /* step 7 */ \
    COEX(V + GetVectorIndex4(4), V + GetVectorIndex4(8), COEX_OP, Sort4Type, __VA_ARGS__); /* step 8 */ \
\
    Sort_4(V + GetVectorIndex4(4), Sort4Type, COEX_SHUFFLE_OP, __VA_ARGS__); /* sort the eight medians in v[4] */ \
\
    return Average(V[4 * 4 + 1], V[4 * 4 + 2]);  /* compute next pivot */ \
}

/* auto generated permutations masks for quicksort */
const uniform int32 Permutation_4_Masks[16][4] = {{0, 1, 2, 3},
                                            {1, 2, 3, 0},
                                            {0, 2, 3, 1},
                                            {2, 3, 0, 1},
                                            {0, 1, 3, 2},
                                            {1, 3, 0, 2},
                                            {0, 3, 1, 2},
                                            {3, 0, 1, 2},
                                            {0, 1, 2, 3},
                                            {1, 2, 0, 3},
                                            {0, 2, 1, 3},
                                            {2, 0, 1, 3},
                                            {0, 1, 2, 3},
                                            {1, 0, 2, 3},
                                            {0, 1, 2, 3},
                                            {0, 1, 2, 3}};

//inline uniform int Partition_Vec_4(uniform Sort4Type CurVec[], uniform Sort4Type PivotVec[], uniform Sort4Type SmallestVec[], uniform Sort4Type BiggestVec[])
#define Partition_Vec_4(Sort4Type, CurVec, PivotVec, SmallestVec, BiggestVec, Calc_Min_OP, Calc_Max_OP, Compare_OP) \
{ \
    /* which elements are larger than the pivot */ \
    /* extract the most significant bit from each integer of the vector */ \
    uniform int32 MoveMask = packmask(CurVec[programIndex] Compare_OP PivotVec[programIndex]); \
\
    prefetch_l1(&Permutation_4_Masks[0]); \
\
    /* update the smallest and largest values of the array */ \
    foreach (pvi = 0 ... 4) \
    { \
        SmallestVec[pvi] = Calc_Min_OP(SmallestVec[pvi], CurVec[pvi]); \
        BiggestVec[pvi] = Calc_Max_OP(BiggestVec[pvi], CurVec[pvi]); \
    } \
\
    /* how many ones, each 1 stands for an element greater than pivot */ \
    uniform int32 Amount_GT_Pivot = popcnt(MoveMask); \
\
    Shuffle4_One_Vector_To_Vector(Sort4Type, CurVec, CurVec, Permutation_4_Masks[MoveMask]); \
\
    return Amount_GT_Pivot; \
}

// inline uniform Sort4Type Calc_Min_4(uniform Sort4Type V[])
#define Calc_Min_4(Sort4Type, V, FinalValue, Calc_Min_OP) \
{ \
    uniform int Mask[4] = {3, 2, 1, 0}; \
    uniform Sort4Type Temp[4]; \
    Shuffle4_One_Vector_To_Vector(Sort4Type, V, Temp, Mask); \
\
    foreach (ci = 0 ... 4) \
    { \
        V[ci] = Calc_Min_OP(V[ci], Temp[ci]); \
    } \
\
    uniform int Mask1[4] = {1, 0, 3, 2}; \
    Shuffle4_One_Vector_To_Vector(Sort4Type, V, Temp, Mask1); \
\
    foreach (ci = 0 ... 4) \
    { \
        V[ci] = Calc_Min_OP(V[ci], Temp[ci]); \
    } \
\
    FinalValue = V[0]; \
    /*return V[0];*/ \
}

// inline uniform Sort4Type Calc_Max_4(uniform Sort4Type V[])
#define Calc_Max_4(Sort4Type, V, FinalValue, Calc_Max_OP) \
{ \
    uniform int Mask[4] = {3, 2, 1, 0}; \
    uniform Sort4Type Temp[4]; \
    Shuffle4_One_Vector_To_Vector(Sort4Type, V, Temp, Mask); \
\
    foreach (ci = 0 ... 4) \
    { \
        V[ci] = Calc_Max_OP(V[ci], Temp[ci]); \
    } \
\
    uniform int Mask1[4] = {1, 0, 3, 2}; \
    Shuffle4_One_Vector_To_Vector(Sort4Type, V, Temp, Mask1); \
\
    foreach (ci = 0 ... 4) \
    { \
        V[ci] = Calc_Max_OP(V[ci], Temp[ci]); \
    } \
\
    FinalValue = V[0]; \
    /*return V[0];*/ \
}

// inline void Load_Vector_4(uniform Sort4Type Src[], uniform Sort4Type Dest[])
#define Load_Vector_4(Src, Dest) \
{ \
    foreach(li = 0 ... 4) \
    { \
        (Dest)[li] = (Src)[li]; \
    } \
}

// inline void Store_Vector_4(uniform Sort4Type Src[], uniform Sort4Type Dest[])
#define Store_Vector_4(Src, Dest) \
{ \
    foreach(si = 0 ... 4) \
    { \
        (Dest)[si] = (Src)[si]; \
    } \
}

//inline uniform uint32 Partition_Vectorized_4(uniform Sort4Type Data[], uniform uint32 Left, uniform uint32 Right, uniform Sort4Type Pivot, uniform Sort4Type* uniform Smallest, uniform Sort4Type* uniform Biggest)
#define Partition_Vectorized_4(Sort4Type, Data, Left, Right, Pivot, Smallest, Biggest, Calc_Min_OP, Calc_Max_OP, Compare_OP, Partition_Vec_4_Func) \
{ \
    /* make array length divisible by four, shortening the array */ \
    for (uniform int32 i = (Right - Left) % 4; i > 0; --i) \
    { \
        Smallest = Calc_Min_OP(Smallest, Data[Left]); \
        Biggest = Calc_Max_OP(Biggest, Data[Left]); \
\
        if (Data[Left] Compare_OP Pivot) \
        { \
            --Right; \
            uniform Sort4Type TempValue = Data[Left]; \
            Data[Left] = Data[Right]; \
            Data[Right] = TempValue; \
        } \
        else \
        { \
            ++Left; \
        } \
    } \
\
    /* less than 4 elements in the array */ \
    if (Left == Right) \
    { \
        return Left; \
    } \
    else \
    { \
        /* fill vector with pivot */ \
        uniform Sort4Type PivotVec[4]; \
        foreach (i = 0 ... 4) \
        { \
            PivotVec[i] = Pivot; \
        } \
\
        /* vector for smallest elements */ \
        uniform Sort4Type SmallestVec[4]; \
        foreach (i = 0 ... 4) \
        { \
            SmallestVec[i] = Smallest; \
        } \
\
        /* vector for biggest elements */ \
        uniform Sort4Type BiggestVec[4]; \
        foreach (i = 0 ... 4) \
        { \
            BiggestVec[i] = Biggest; \
        } \
\
        if (Right - Left == 4) \
        { \
            /* if 4 elements Left after shortening */ \
            uniform Sort4Type Vec_Left[4]; \
            Load_Vector_4(Data + Left, Vec_Left); \
            uniform int32 Amount_GT_Pivot = Partition_Vec_4_Func(Vec_Left, PivotVec, SmallestVec, BiggestVec); \
            Store_Vector_4(Vec_Left, Data + Left); \
\
            Calc_Min_4(Sort4Type, SmallestVec, Smallest, Calc_Min_OP); \
            Calc_Max_4(Sort4Type, BiggestVec, Biggest, Calc_Max_OP); \
            return Left + (4 - Amount_GT_Pivot); \
        } \
        else \
        { \
            /* first and last 4 values are partitioned at the end */ \
            uniform Sort4Type Vec_Left[4]; \
            Load_Vector_4(Data + Left, Vec_Left);          /* first 4 values */ \
\
            uniform Sort4Type Vec_Right[4]; \
            Load_Vector_4(Data + (Right - 4), Vec_Right);  /* last 4 values  */ \
\
            /* store points of the vectors */ \
            uniform uint32 R_Store = Right - 4; /* Right store point */ \
            uniform uint32 L_Store = Left;      /* Left store point */ \
\
            /* indices for loading the elements */ \
            Left += 4;   /* increase, because first 4 elements are cached */ \
            Right -= 4;  /* decrease, because last 4 elements are cached */ \
\
            while (Right - Left != 0) \
            { \
                /* partition 4 elements per iteration */ \
                uniform Sort4Type Curr_Vec[4]; /* vector to be partitioned */ \
\
                /* if fewer elements are stored on the Right side of the array, 
                * then next elements are loaded from the Right side,  
                * otherwise from the Left side */ \
                if ((R_Store + 4) - Right < Left - L_Store) \
                { \
                    Right -= 4; \
                    Load_Vector_4(Data + Right, Curr_Vec); \
                } \
                else \
                { \
                    Load_Vector_4(Data + Left, Curr_Vec); \
                    Left += 4; \
                } \
\
                /* partition the current vector and save it on both sides of the array */ \
                uniform int32 Amount_GT_Pivot = Partition_Vec_4_Func(Curr_Vec, PivotVec, SmallestVec, BiggestVec); \
                Store_Vector_4(Curr_Vec, Data + L_Store); \
                Store_Vector_4(Curr_Vec, Data + R_Store); \
\
                /* update store points */ \
                R_Store -= Amount_GT_Pivot; \
                L_Store += (4 - Amount_GT_Pivot); \
            } \
\
            /* partition and save Vec_Left */ \
            uniform int32 Amount_GT_Pivot = Partition_Vec_4_Func(Vec_Left, PivotVec, SmallestVec, BiggestVec); \
            Store_Vector_4(Vec_Left, Data + L_Store); \
            Store_Vector_4(Vec_Left, Data + R_Store); \
            L_Store += (4 - Amount_GT_Pivot); \
\
            /* partition and save Vec_Right */ \
            Amount_GT_Pivot = Partition_Vec_4_Func(Vec_Right, PivotVec, SmallestVec, BiggestVec); \
            Store_Vector_4(Vec_Right, Data + L_Store); \
            L_Store += (4 - Amount_GT_Pivot); \
\
            Calc_Min_4(Sort4Type, SmallestVec, Smallest, Calc_Min_OP); /* determine smallest value in vector */ \
            Calc_Max_4(Sort4Type, BiggestVec, Biggest, Calc_Max_OP);   /* determine largest value in vector */ \
            return L_Store; \
        } \
    } \
}

//inline uniform uint32 Partition_Vectorized_32(uniform Sort4Type Data[], uniform uint32 Left, uniform uint32 Right, uniform Sort4Type Pivot, uniform Sort4Type* uniform Smallest, uniform Sort4Type* uniform Biggest)
#define Partition_Vectorized_32(Sort4Type, Data, Left, Right, Pivot, Smallest, Biggest, Calc_Min_OP, Calc_Max_OP, Compare_OP, Partition_Vectorized_4_Func, Partition_Vec_4_Func) \
{ \
    if (Right - Left < 65) \
    { \
        /* do not optimize if less than 65 elements */ \
        return Partition_Vectorized_4_Func(Data, Left, Right, Pivot, Smallest, Biggest); \
    } \
    else \
    { \
        /* make array length divisible by four, shortening the array */ \
        for (uniform uint32 i = (Right - Left) % 4; i > 0; --i) \
        { \
            Smallest = Calc_Min_OP(Smallest, Data[Left]); \
            Biggest = Calc_Max_OP(Biggest, Data[Left]); \
\
            if (Data[Left] Compare_OP Pivot) \
            { \
                --Right; \
                uniform Sort4Type TempValue = Data[Left]; \
                Data[Left] = Data[Right]; \
                Data[Right] = TempValue; \
            } \
            else \
            { \
                ++Left; \
            } \
        } \
\
        /* fill vector with pivot */ \
        uniform Sort4Type PivotVec[4]; \
        foreach (i = 0 ... 4) \
        { \
            PivotVec[i] = Pivot; \
        } \
\
        /* vector for smallest elements */ \
        uniform Sort4Type SmallestVec[4]; \
        foreach (i = 0 ... 4) \
        { \
            SmallestVec[i] = Smallest; \
        } \
\
        /* vector for biggest elements */ \
        uniform Sort4Type BiggestVec[4]; \
        foreach (i = 0 ... 4) \
        { \
            BiggestVec[i] = Biggest; \
        } \
\
        /* make array length divisible by 32, shortening the array */ \
        for (uniform int32 i = ((Right - Left) % 32) / 4; i > 0; --i) \
        { \
            uniform Sort4Type CurVec[4]; \
            Load_Vector_4(Data + Left, CurVec); \
\
            /* which elements are larger than the pivot */ \
            /* extract the most significant bit from each integer of the vector */ \
            uniform int32 MoveMask = packmask(CurVec[programIndex] Compare_OP PivotVec[programIndex]); \
\
            prefetch_l1(&Permutation_4_Masks[0]); \
\
            /* update the smallest and largest values of the array */ \
            foreach (pvi = 0 ... 4) \
            { \
                SmallestVec[pvi] = Calc_Min_OP(SmallestVec[pvi], CurVec[pvi]); \
            } \
\
            foreach (pvi = 0 ... 4) \
            { \
                BiggestVec[pvi] = Calc_Max_OP(BiggestVec[pvi], CurVec[pvi]); \
            } \
\
            /* how many ones, each 1 stands for an element greater than pivot */ \
            uniform int32 Amount_GT_Pivot = popcnt(MoveMask); \
\
            Shuffle4_One_Vector_To_Vector(Sort4Type, CurVec, CurVec, Permutation_4_Masks[MoveMask]); \
\
            /* this is a slower way to partition an array with vector instructions */ \
            uniform uint32 Compared[4]; \
            foreach (j = 0 ... 4) \
            { \
                Compared[j] = sign_extend(CurVec[j] Compare_OP PivotVec[j]); \
            } \
\
            uniform Sort4Type Vec_Right[4]; \
            Load_Vector_4(Data + Right - 4, Vec_Right); \
\
            uniform Sort4Type Vec_L_New[4]; \
            foreach (j = 0 ... 4) \
            { \
                Vec_L_New[j] = select((bool)Compared[j], Vec_Right[j], CurVec[j]); \
            } \
\
            uniform Sort4Type Vec_R_New[4]; \
            foreach (j = 0 ... 4) \
            { \
                Vec_R_New[j] = select((bool)Compared[j], CurVec[j], Vec_Right[j]); \
            } \
\
            Store_Vector_4(Vec_L_New, Data + Left); \
            Store_Vector_4(Vec_R_New, Data + Right - 4); \
\
            Left += (4 - Amount_GT_Pivot); \
            Right -= Amount_GT_Pivot; \
        } \
\
        /* buffer 4 vectors from both sides of the array */ \
        uniform Sort4Type Vec_Left[4]; \
        uniform Sort4Type Vec_Left2[4]; \
        uniform Sort4Type Vec_Left3[4]; \
        uniform Sort4Type Vec_Left4[4]; \
        uniform Sort4Type Vec_Left5[4]; \
        uniform Sort4Type Vec_Left6[4]; \
        uniform Sort4Type Vec_Left7[4]; \
        uniform Sort4Type Vec_Left8[4]; \
        Load_Vector_4(Data + Left, Vec_Left); \
        Load_Vector_4(Data + Left + 4, Vec_Left2); \
        Load_Vector_4(Data + Left + 8, Vec_Left3); \
        Load_Vector_4(Data + Left + 12, Vec_Left4); \
        Load_Vector_4(Data + Left + 16, Vec_Left5); \
        Load_Vector_4(Data + Left + 20, Vec_Left6); \
        Load_Vector_4(Data + Left + 24, Vec_Left7); \
        Load_Vector_4(Data + Left + 28, Vec_Left8); \
\
        uniform Sort4Type Vec_Right[4]; \
        uniform Sort4Type Vec_Right2[4]; \
        uniform Sort4Type Vec_Right3[4]; \
        uniform Sort4Type Vec_Right4[4]; \
        uniform Sort4Type Vec_Right5[4]; \
        uniform Sort4Type Vec_Right6[4]; \
        uniform Sort4Type Vec_Right7[4]; \
        uniform Sort4Type Vec_Right8[4]; \
        Load_Vector_4(Data + (Right - 32), Vec_Right); \
        Load_Vector_4(Data + (Right - 28), Vec_Right2); \
        Load_Vector_4(Data + (Right - 24), Vec_Right3); \
        Load_Vector_4(Data + (Right - 20), Vec_Right4); \
        Load_Vector_4(Data + (Right - 16), Vec_Right5); \
        Load_Vector_4(Data + (Right - 12), Vec_Right6); \
        Load_Vector_4(Data + (Right - 8), Vec_Right7); \
        Load_Vector_4(Data + (Right - 4), Vec_Right8); \
\
        /* store points of the vectors */ \
        uniform uint32 R_Store = Right - 32; /* Right store point */ \
        uniform uint32 L_Store = Left; /* Left store point */ \
        /* indices for loading the elements */ \
        Left += 32; /* increase because first 32 elements are cached */ \
        Right -= 32; /* decrease because last 32 elements are cached */ \
\
        while (Right - Left != 0) \
        { \
            /* partition 32 elements per iteration */ \
            uniform Sort4Type Curr_Vec[4]; \
            uniform Sort4Type Curr_Vec2[4]; \
            uniform Sort4Type Curr_Vec3[4]; \
            uniform Sort4Type Curr_Vec4[4]; \
            uniform Sort4Type Curr_Vec5[4]; \
            uniform Sort4Type Curr_Vec6[4]; \
            uniform Sort4Type Curr_Vec7[4]; \
            uniform Sort4Type Curr_Vec8[4]; \
\
            /* if less elements are stored on the Right side of the array, \
            * then next 4 vectors load from the Right side, otherwise load from the Left side */ \
            if ((R_Store + 32) - Right < Left - L_Store) \
            { \
                Right -= 32; \
                Load_Vector_4(Data + Right, Curr_Vec); Load_Vector_4(Data + Right + 4, Curr_Vec2); \
                Load_Vector_4(Data + Right + 8, Curr_Vec3); Load_Vector_4(Data + Right + 12, Curr_Vec4); \
                Load_Vector_4(Data + Right + 16, Curr_Vec5); Load_Vector_4(Data + Right + 20, Curr_Vec6); \
                Load_Vector_4(Data + Right + 24, Curr_Vec7); Load_Vector_4(Data + Right + 28, Curr_Vec8); \
            } \
            else \
            { \
                Load_Vector_4(Data + Left, Curr_Vec); Load_Vector_4(Data + Left + 4, Curr_Vec2); \
                Load_Vector_4(Data + Left + 8, Curr_Vec3); Load_Vector_4(Data + Left + 12, Curr_Vec4); \
                Load_Vector_4(Data + Left + 16, Curr_Vec5); Load_Vector_4(Data + Left + 20, Curr_Vec6); \
                Load_Vector_4(Data + Left + 24, Curr_Vec7); Load_Vector_4(Data + Left + 28, Curr_Vec8); \
                Left += 32; \
            } \
\
            /* partition 4 vectors and store them on both sides of the array */ \
            uniform int32 Amount_GT_Pivot = Partition_Vec_4_Func(Curr_Vec, PivotVec, SmallestVec, BiggestVec); \
            uniform int32 Amount_GT_Pivot2 = Partition_Vec_4_Func(Curr_Vec2, PivotVec, SmallestVec, BiggestVec); \
            uniform int32 Amount_GT_Pivot3 = Partition_Vec_4_Func(Curr_Vec3, PivotVec, SmallestVec, BiggestVec); \
            uniform int32 Amount_GT_Pivot4 = Partition_Vec_4_Func(Curr_Vec4, PivotVec, SmallestVec, BiggestVec); \
            uniform int32 Amount_GT_Pivot5 = Partition_Vec_4_Func(Curr_Vec5, PivotVec, SmallestVec, BiggestVec); \
            uniform int32 Amount_GT_Pivot6 = Partition_Vec_4_Func(Curr_Vec6, PivotVec, SmallestVec, BiggestVec); \
            uniform int32 Amount_GT_Pivot7 = Partition_Vec_4_Func(Curr_Vec7, PivotVec, SmallestVec, BiggestVec); \
            uniform int32 Amount_GT_Pivot8 = Partition_Vec_4_Func(Curr_Vec8, PivotVec, SmallestVec, BiggestVec); \
\
            Store_Vector_4(Curr_Vec, Data + L_Store); L_Store += (4 - Amount_GT_Pivot); \
            Store_Vector_4(Curr_Vec2, Data + L_Store); L_Store += (4 - Amount_GT_Pivot2); \
            Store_Vector_4(Curr_Vec3, Data + L_Store); L_Store += (4 - Amount_GT_Pivot3); \
            Store_Vector_4(Curr_Vec4, Data + L_Store); L_Store += (4 - Amount_GT_Pivot4); \
            Store_Vector_4(Curr_Vec5, Data + L_Store); L_Store += (4 - Amount_GT_Pivot5); \
            Store_Vector_4(Curr_Vec6, Data + L_Store); L_Store += (4 - Amount_GT_Pivot6); \
            Store_Vector_4(Curr_Vec7, Data + L_Store); L_Store += (4 - Amount_GT_Pivot7); \
            Store_Vector_4(Curr_Vec8, Data + L_Store); L_Store += (4 - Amount_GT_Pivot8); \
\
            Store_Vector_4(Curr_Vec, Data + R_Store + 28); R_Store -= Amount_GT_Pivot; \
            Store_Vector_4(Curr_Vec2, Data + R_Store + 28); R_Store -= Amount_GT_Pivot2; \
            Store_Vector_4(Curr_Vec3, Data + R_Store + 28); R_Store -= Amount_GT_Pivot3; \
            Store_Vector_4(Curr_Vec4, Data + R_Store + 28); R_Store -= Amount_GT_Pivot4; \
            Store_Vector_4(Curr_Vec5, Data + R_Store + 28); R_Store -= Amount_GT_Pivot5; \
            Store_Vector_4(Curr_Vec6, Data + R_Store + 28); R_Store -= Amount_GT_Pivot6; \
            Store_Vector_4(Curr_Vec7, Data + R_Store + 28); R_Store -= Amount_GT_Pivot7; \
            Store_Vector_4(Curr_Vec8, Data + R_Store + 28); R_Store -= Amount_GT_Pivot8; \
        } \
\
        /* partition and store 4 vectors coming from the Left side of the array */ \
        uniform int32 Amount_GT_Pivot = Partition_Vec_4_Func(Vec_Left, PivotVec, SmallestVec, BiggestVec); \
        uniform int32 Amount_GT_Pivot2 = Partition_Vec_4_Func(Vec_Left2, PivotVec, SmallestVec, BiggestVec); \
        uniform int32 Amount_GT_Pivot3 = Partition_Vec_4_Func(Vec_Left3, PivotVec, SmallestVec, BiggestVec); \
        uniform int32 Amount_GT_Pivot4 = Partition_Vec_4_Func(Vec_Left4, PivotVec, SmallestVec, BiggestVec); \
        uniform int32 Amount_GT_Pivot5 = Partition_Vec_4_Func(Vec_Left5, PivotVec, SmallestVec, BiggestVec); \
        uniform int32 Amount_GT_Pivot6 = Partition_Vec_4_Func(Vec_Left6, PivotVec, SmallestVec, BiggestVec); \
        uniform int32 Amount_GT_Pivot7 = Partition_Vec_4_Func(Vec_Left7, PivotVec, SmallestVec, BiggestVec); \
        uniform int32 Amount_GT_Pivot8 = Partition_Vec_4_Func(Vec_Left8, PivotVec, SmallestVec, BiggestVec); \
\
        Store_Vector_4(Vec_Left, Data + L_Store); L_Store += (4 - Amount_GT_Pivot); \
        Store_Vector_4(Vec_Left2, Data + L_Store); L_Store += (4 - Amount_GT_Pivot2); \
        Store_Vector_4(Vec_Left3, Data + L_Store); L_Store += (4 - Amount_GT_Pivot3); \
        Store_Vector_4(Vec_Left4, Data + L_Store); L_Store += (4 - Amount_GT_Pivot4); \
        Store_Vector_4(Vec_Left5, Data + L_Store); L_Store += (4 - Amount_GT_Pivot5); \
        Store_Vector_4(Vec_Left6, Data + L_Store); L_Store += (4 - Amount_GT_Pivot6); \
        Store_Vector_4(Vec_Left7, Data + L_Store); L_Store += (4 - Amount_GT_Pivot7); \
        Store_Vector_4(Vec_Left8, Data + L_Store); L_Store += (4 - Amount_GT_Pivot8); \
\
        Store_Vector_4(Vec_Left, Data + R_Store + 28); R_Store -= Amount_GT_Pivot; \
        Store_Vector_4(Vec_Left2, Data + R_Store + 28); R_Store -= Amount_GT_Pivot2; \
        Store_Vector_4(Vec_Left3, Data + R_Store + 28); R_Store -= Amount_GT_Pivot3; \
        Store_Vector_4(Vec_Left4, Data + R_Store + 28); R_Store -= Amount_GT_Pivot4; \
        Store_Vector_4(Vec_Left5, Data + R_Store + 28); R_Store -= Amount_GT_Pivot5; \
        Store_Vector_4(Vec_Left6, Data + R_Store + 28); R_Store -= Amount_GT_Pivot6; \
        Store_Vector_4(Vec_Left7, Data + R_Store + 28); R_Store -= Amount_GT_Pivot7; \
        Store_Vector_4(Vec_Left8, Data + R_Store + 28); R_Store -= Amount_GT_Pivot8; \
\
        /* partition and store 4 vectors coming from the Right side of the array */ \
        Amount_GT_Pivot = Partition_Vec_4_Func(Vec_Right, PivotVec, SmallestVec, BiggestVec); \
        Amount_GT_Pivot2 = Partition_Vec_4_Func(Vec_Right2, PivotVec, SmallestVec, BiggestVec); \
        Amount_GT_Pivot3 = Partition_Vec_4_Func(Vec_Right3, PivotVec, SmallestVec, BiggestVec); \
        Amount_GT_Pivot4 = Partition_Vec_4_Func(Vec_Right4, PivotVec, SmallestVec, BiggestVec); \
        Amount_GT_Pivot5 = Partition_Vec_4_Func(Vec_Right5, PivotVec, SmallestVec, BiggestVec); \
        Amount_GT_Pivot6 = Partition_Vec_4_Func(Vec_Right6, PivotVec, SmallestVec, BiggestVec); \
        Amount_GT_Pivot7 = Partition_Vec_4_Func(Vec_Right7, PivotVec, SmallestVec, BiggestVec); \
        Amount_GT_Pivot8 = Partition_Vec_4_Func(Vec_Right8, PivotVec, SmallestVec, BiggestVec); \
\
        Store_Vector_4(Vec_Right, Data + L_Store); L_Store += (4 - Amount_GT_Pivot); \
        Store_Vector_4(Vec_Right2, Data + L_Store); L_Store += (4 - Amount_GT_Pivot2); \
        Store_Vector_4(Vec_Right3, Data + L_Store); L_Store += (4 - Amount_GT_Pivot3); \
        Store_Vector_4(Vec_Right4, Data + L_Store); L_Store += (4 - Amount_GT_Pivot4); \
        Store_Vector_4(Vec_Right5, Data + L_Store); L_Store += (4 - Amount_GT_Pivot5); \
        Store_Vector_4(Vec_Right6, Data + L_Store); L_Store += (4 - Amount_GT_Pivot6); \
        Store_Vector_4(Vec_Right7, Data + L_Store); L_Store += (4 - Amount_GT_Pivot7); \
        Store_Vector_4(Vec_Right8, Data + L_Store); L_Store += (4 - Amount_GT_Pivot8); \
\
        Store_Vector_4(Vec_Right, Data + R_Store + 28); R_Store -= Amount_GT_Pivot; \
        Store_Vector_4(Vec_Right2, Data + R_Store + 28); R_Store -= Amount_GT_Pivot2; \
        Store_Vector_4(Vec_Right3, Data + R_Store + 28); R_Store -= Amount_GT_Pivot3; \
        Store_Vector_4(Vec_Right4, Data + R_Store + 28); R_Store -= Amount_GT_Pivot4; \
        Store_Vector_4(Vec_Right5, Data + R_Store + 28); R_Store -= Amount_GT_Pivot5; \
        Store_Vector_4(Vec_Right6, Data + R_Store + 28); R_Store -= Amount_GT_Pivot6; \
        Store_Vector_4(Vec_Right7, Data + R_Store + 28); R_Store -= Amount_GT_Pivot7; \
        Store_Vector_4(Vec_Right8, Data + R_Store + 28); \
\
        Calc_Min_4(Sort4Type, SmallestVec, Smallest, Calc_Min_OP); /* determine smallest value in vector */ \
        Calc_Max_4(Sort4Type, BiggestVec, Biggest, Calc_Max_OP);  /* determine largest value in vector */ \
\
        return L_Store; \
    } \
}

// void QuickSort4_NR(uniform Sort4Type Data[], uniform uint32 InLeft, uniform uint32 InRight, uniform Sort4Type MaxValue, uniform Sort4Type MinValue, uniform bool Choose_Avg, uniform Sort4Type InAvg)
#define QuickSort4_NR(Sort4Type, Data, InLeft, InRight, MaxValue, MinValue, Choose_Avg, InAvg, COEX_OP, COEX_SHUFFLE_OP, GetPivot_Func, Partition_Vectorized_32_Func) \
{ \
    uniform uint32 Range_StackMem[STACK_INIT_SIZE]; \
    uniform uint32* uniform Range_HeapMem = NULL; \
    uniform uint32* uniform Range_Base = &Range_StackMem[0]; \
    uniform uint32 Range_Top = -1; \
    uniform uint32 Range_StackSize = STACK_INIT_SIZE; \
\
    PushValue(uint32, Range_Top, Range_Base, Range_StackMem, Range_HeapMem, Range_StackSize, InRight); \
    PushValue(uint32, Range_Top, Range_Base, Range_StackMem, Range_HeapMem, Range_StackSize, InLeft); \
\
    uniform Sort4Type Avg_StackMem[STACK_INIT_SIZE]; \
    uniform Sort4Type* uniform Avg_HeapMem = NULL; \
    uniform Sort4Type* uniform Avg_Base = &Avg_StackMem[0]; \
    uniform uint32 Avg_Top = -1; \
    uniform uint32 Avg_StackSize = STACK_INIT_SIZE; \
\
    PushValue(Sort4Type, Avg_Top, Avg_Base, Avg_StackMem, Avg_HeapMem, Avg_StackSize, InAvg); \
\
    while (!StackIsEmpty(Range_Top)) \
    { \
        uniform Sort4Type Avg; \
        PopValue(Sort4Type, Avg_Top, Avg_Base, Avg); \
\
        uniform uint32 Left; \
        PopValue(uint32, Range_Top, Range_Base, Left); \
\
        uniform uint32 Right; \
        PopValue(uint32, Range_Top, Range_Base, Right); \
\
        if (Right - Left < 257) \
        { \
            /* use sorting networks for small arrays */ \
            uniform Sort4Type Buffer[260]; /* buffer for sorting networks */ \
            uniform Sort4Type* DataLeft = Data + Left; \
            uniform uint32 DataSize = Right - Left + 1; \
            Sort4_Sorting_Network_Impl(Sort4Type, DataLeft, DataSize, Buffer, MaxValue, COEX_OP, COEX_SHUFFLE_OP); \
            continue; \
        } \
\
        /* avg is average of largest and smallest values in array */ \
        uniform Sort4Type Pivot = Choose_Avg ? Avg : GetPivot_Func(Data, Left, Right); \
\
        uniform Sort4Type Smallest = MaxValue;  /* smallest value after partitioning */ \
        uniform Sort4Type Biggest = MinValue;   /* largest value after partitioning */ \
\
        uniform uint32 Bound = Partition_Vectorized_32_Func(Data, Left, Right + 1, Pivot, Smallest, Biggest); \
\
        /* the ratio of the length of the smaller partition to the array length */ \
        uniform double Ratio = (min(Right - (Bound - 1), Bound - Left) / (uniform double)(Right - Left + 1)); \
\
        /* if unbalanced sub-arrays, change pivot selection strategy */ \
        if (Ratio < 0.2) \
        { \
            Choose_Avg = !Choose_Avg; \
        } \
\
        if (Pivot != Smallest) /* if values in the Left sub-array are not identical */ \
        { \
            PushValue(uint32, Range_Top, Range_Base, Range_StackMem, Range_HeapMem, Range_StackSize, Bound - 1); \
            PushValue(uint32, Range_Top, Range_Base, Range_StackMem, Range_HeapMem, Range_StackSize, Left); \
            PushValue(Sort4Type, Avg_Top, Avg_Base, Avg_StackMem, Avg_HeapMem, Avg_StackSize, Average(Smallest, Pivot)); \
        } \
\
        if (Pivot + 1 != Biggest) /* if values in the Right sub-array are not identical */ \
        { \
            PushValue(uint32, Range_Top, Range_Base, Range_StackMem, Range_HeapMem, Range_StackSize, Right); \
            PushValue(uint32, Range_Top, Range_Base, Range_StackMem, Range_HeapMem, Range_StackSize, Bound); \
            PushValue(Sort4Type, Avg_Top, Avg_Base, Avg_StackMem, Avg_HeapMem, Avg_StackSize, Average(Biggest, Pivot)); \
        } \
    } \
\
    if (Range_HeapMem != NULL) \
    { \
        delete[] Range_HeapMem; \
        Range_HeapMem = NULL; \
    } \
\
    if (Avg_HeapMem != NULL) \
    { \
        delete[] Avg_HeapMem; \
        Avg_HeapMem = NULL; \
    } \
}

#if TARGET_WIDTH == 4

//====================================================================================================== int32

inline uniform int32 GetPivot4_Int32_ASC(uniform int32 Data[], uniform uint32 Left, uniform uint32 Right)
{
    GetPivot4(int32, Data, Left, Right, COEX_4_ASC, COEX_SHUFFLE_4_ASC);
}

inline uniform uint32 Partition_Vec_4_Int32_ASC(uniform int32 CurVec[], uniform int32 PivotVec[], uniform int32 SmallestVec[], uniform int32 BiggestVec[])
{
    Partition_Vec_4(int32, CurVec, PivotVec, SmallestVec, BiggestVec, min, max, >)
}

inline uniform uint32 Partition_Vectorized_4_Int32_ASC(uniform int32 Data[], uniform uint32 Left, uniform uint32 Right, uniform int32 Pivot, uniform int32& Smallest, uniform int32& Biggest)
{
    Partition_Vectorized_4(int32, Data, Left, Right, Pivot, Smallest, Biggest, min, max, >, Partition_Vec_4_Int32_ASC);
}

inline uniform uint32 Partition_Vectorized_32_Int32_ASC(uniform int32 Data[], uniform uint32 Left, uniform uint32 Right, uniform int32 Pivot, uniform int32& Smallest, uniform int32& Biggest)
{
    Partition_Vectorized_32(int32, Data, Left, Right, Pivot, Smallest, Biggest, min, max, >, Partition_Vectorized_4_Int32_ASC, Partition_Vec_4_Int32_ASC);
}

void QuickSort4_Int32_ASC_NR(uniform int32 Data[], uniform uint32 InLeft, uniform uint32 InRight, uniform int32 MaxValue, 
    uniform int32 MinValue, uniform bool Choose_Avg, uniform int32 InAvg)
{
    QuickSort4_NR(int32, Data, InLeft, InRight, MaxValue, MinValue, Choose_Avg, InAvg, COEX_4_ASC, COEX_SHUFFLE_4_ASC, GetPivot4_Int32_ASC, Partition_Vectorized_32_Int32_ASC);
}

inline void QuickSort4_Int32_ASC_Impl(uniform int32 Data[], uniform uint32 Left, uniform uint32 Right, 
    uniform bool Choose_Avg = false, uniform int32 Avg = 0, uniform int16 RemainingLevels = 40)
{
    if (Right - Left < 257)
    {
        /* use sorting networks for small arrays */
        uniform int32 Buffer[260]; /* buffer for sorting networks */
        uniform int32* DataLeft = Data + Left;
        uniform uint32 DataSize = Right - Left + 1;
        Sort4_Sorting_Network_Impl(int32, DataLeft, DataSize, Buffer, MAX_int32, COEX_4_ASC, COEX_SHUFFLE_4_ASC);
        return;
    }

    if (RemainingLevels <= 0)
    {
        QuickSort4_Int32_ASC_NR(Data, Left, Right, MAX_int32, MIN_int32, Choose_Avg, Avg);
        return;
    }

    /* avg is average of largest and smallest values in array */
    uniform int32 Pivot = Choose_Avg ? Avg : GetPivot4_Int32_ASC(Data, Left, Right);

    uniform int32 Smallest = MAX_int32;  /* smallest value after partitioning */ 
    uniform int32 Biggest = MIN_int32;   /* largest value after partitioning */
    
    uniform uint32 Bound = Partition_Vectorized_32_Int32_ASC(Data, Left, Right + 1, Pivot, Smallest, Biggest);

    /* the ratio of the length of the smaller partition to the array length */
    uniform double Ratio = (min(Right - (Bound - 1), Bound - Left) / (uniform double)(Right - Left + 1));
        
    /* if unbalanced sub-arrays, change pivot selection strategy */
    if (Ratio < 0.2)
    {
        Choose_Avg = !Choose_Avg;
    }

    if (Pivot != Smallest) /* if values in the Left sub-array are not identical */
    {   
        QuickSort4_Int32_ASC_Impl(Data, Left, Bound - 1, Choose_Avg, Average(Smallest, Pivot), RemainingLevels);
    }
            
    if (Pivot + 1 != Biggest) /* if values in the Right sub-array are not identical */
    {   
        QuickSort4_Int32_ASC_Impl(Data, Bound, Right, Choose_Avg, Average(Biggest, Pivot), RemainingLevels);
    }
}

inline uniform int32 GetPivot4_Int32_DESC(uniform int32 Data[], uniform uint32 Left, uniform uint32 Right)
{
    GetPivot4(int32, Data, Left, Right, COEX_4_DESC, COEX_SHUFFLE_4_DESC);
}

inline uniform uint32 Partition_Vec_4_Int32_DESC(uniform int32 CurVec[], uniform int32 PivotVec[], uniform int32 SmallestVec[], uniform int32 BiggestVec[])
{
    Partition_Vec_4(int32, CurVec, PivotVec, SmallestVec, BiggestVec, max, min, <)
}

inline uniform uint32 Partition_Vectorized_4_Int32_DESC(uniform int32 Data[], uniform uint32 Left, uniform uint32 Right, uniform int32 Pivot, uniform int32& Smallest, uniform int32& Biggest)
{
    Partition_Vectorized_4(int32, Data, Left, Right, Pivot, Smallest, Biggest, max, min, <, Partition_Vec_4_Int32_DESC);
}

inline uniform uint32 Partition_Vectorized_32_Int32_DESC(uniform int32 Data[], uniform uint32 Left, uniform uint32 Right, uniform int32 Pivot, uniform int32& Smallest, uniform int32& Biggest)
{
    Partition_Vectorized_32(int32, Data, Left, Right, Pivot, Smallest, Biggest, max, min, <, Partition_Vectorized_4_Int32_DESC, Partition_Vec_4_Int32_DESC);
}

void QuickSort4_Int32_DESC_NR(uniform int32 Data[], uniform uint32 InLeft, uniform uint32 InRight, uniform int32 MaxValue, 
    uniform int32 MinValue, uniform bool Choose_Avg, uniform int32 InAvg)
{
    QuickSort4_NR(int32, Data, InLeft, InRight, MaxValue, MinValue, Choose_Avg, InAvg, COEX_4_DESC, COEX_SHUFFLE_4_DESC, GetPivot4_Int32_DESC, Partition_Vectorized_32_Int32_DESC);
}

inline void QuickSort4_Int32_DESC_Impl(uniform int32 Data[], uniform uint32 Left, uniform uint32 Right, 
    uniform bool Choose_Avg = false, uniform int32 Avg = 0, uniform int16 RemainingLevels = 40)
{
    if (Right - Left < 257)
    {
        /* use sorting networks for small arrays */
        uniform int32 Buffer[260]; /* buffer for sorting networks */
        uniform int32* DataLeft = Data + Left;
        uniform uint32 DataSize = Right - Left + 1;
        Sort4_Sorting_Network_Impl(int32, DataLeft, DataSize, Buffer, MIN_int32, COEX_4_DESC, COEX_SHUFFLE_4_DESC);
        return;
    }

    if (RemainingLevels <= 0)
    {
        QuickSort4_Int32_DESC_NR(Data, Left, Right, MIN_int32, MAX_int32, Choose_Avg, Avg);
        return;
    }

    /* avg is average of largest and smallest values in array */
    uniform int32 Pivot = Choose_Avg ? Avg : GetPivot4_Int32_DESC(Data, Left, Right);

    uniform int32 Smallest = MIN_int32;  /* smallest value after partitioning */ 
    uniform int32 Biggest = MAX_int32;   /* largest value after partitioning */
    
    uniform uint32 Bound = Partition_Vectorized_32_Int32_DESC(Data, Left, Right + 1, Pivot, Smallest, Biggest);

    /* the ratio of the length of the smaller partition to the array length */
    uniform double Ratio = (min(Right - (Bound - 1), Bound - Left) / (uniform double)(Right - Left + 1));
        
    /* if unbalanced sub-arrays, change pivot selection strategy */
    if (Ratio < 0.2)
    {
        Choose_Avg = !Choose_Avg;
    }

    if (Pivot != Smallest) /* if values in the Left sub-array are not identical */
    {   
        QuickSort4_Int32_DESC_Impl(Data, Left, Bound - 1, Choose_Avg, Average(Smallest, Pivot), RemainingLevels - 1);
    }
            
    if (Pivot + 1 != Biggest) /* if values in the Right sub-array are not identical */
    {   
        QuickSort4_Int32_DESC_Impl(Data, Bound, Right, Choose_Avg, Average(Biggest, Pivot), RemainingLevels - 1);
    }
}

//====================================================================================================== int32 end

//====================================================================================================== float

inline uniform int32 GetPivot4_Float_ASC(uniform float Data[], uniform uint32 Left, uniform uint32 Right)
{
    GetPivot4(float, Data, Left, Right, COEX_4_ASC, COEX_SHUFFLE_4_ASC);
}

inline uniform uint32 Partition_Vec_4_Float_ASC(uniform float CurVec[], uniform float PivotVec[], uniform float SmallestVec[], uniform float BiggestVec[])
{
    Partition_Vec_4(float, CurVec, PivotVec, SmallestVec, BiggestVec, min, max, >)
}

inline uniform uint32 Partition_Vectorized_4_Float_ASC(uniform float Data[], uniform uint32 Left, uniform uint32 Right, uniform float Pivot, uniform float& Smallest, uniform float& Biggest)
{
    Partition_Vectorized_4(float, Data, Left, Right, Pivot, Smallest, Biggest, min, max, >, Partition_Vec_4_Float_ASC);
}

inline uniform uint32 Partition_Vectorized_32_Float_ASC(uniform float Data[], uniform uint32 Left, uniform uint32 Right, uniform float Pivot, uniform float& Smallest, uniform float& Biggest)
{
    Partition_Vectorized_32(float, Data, Left, Right, Pivot, Smallest, Biggest, min, max, >, Partition_Vectorized_4_Float_ASC, Partition_Vec_4_Float_ASC);
}

void QuickSort4_Float_ASC_NR(uniform float Data[], uniform uint32 InLeft, uniform uint32 InRight, uniform float MaxValue, 
    uniform float MinValue, uniform bool Choose_Avg, uniform float InAvg)
{
    QuickSort4_NR(float, Data, InLeft, InRight, MaxValue, MinValue, Choose_Avg, InAvg, COEX_4_ASC, COEX_SHUFFLE_4_ASC, GetPivot4_Float_ASC, Partition_Vectorized_32_Float_ASC);
}

inline void QuickSort4_Float_ASC_Impl(uniform float Data[], uniform uint32 Left, uniform uint32 Right, 
    uniform bool Choose_Avg = false, uniform float Avg = 0, uniform int16 RemainingLevels = 40)
{
    if (Right - Left < 257)
    {
        /* use sorting networks for small arrays */
        uniform float Buffer[260]; /* buffer for sorting networks */
        uniform float* DataLeft = Data + Left;
        uniform uint32 DataSize = Right - Left + 1;
        Sort4_Sorting_Network_Impl(float, DataLeft, DataSize, Buffer, MAX_flt, COEX_4_ASC, COEX_SHUFFLE_4_ASC);
        return;
    }

    if (RemainingLevels <= 0)
    {
        QuickSort4_Float_ASC_NR(Data, Left, Right, MAX_flt, MIN_flt, Choose_Avg, Avg);
        return;
    }

    /* avg is average of largest and smallest values in array */
    uniform float Pivot = Choose_Avg ? Avg : GetPivot4_Float_ASC(Data, Left, Right);

    uniform float Smallest = MAX_flt;  /* smallest value after partitioning */ 
    uniform float Biggest = MIN_flt;   /* largest value after partitioning */
    
    uniform uint32 Bound = Partition_Vectorized_32_Float_ASC(Data, Left, Right + 1, Pivot, Smallest, Biggest);

    /* the ratio of the length of the smaller partition to the array length */
    uniform double Ratio = (min(Right - (Bound - 1), Bound - Left) / (uniform double)(Right - Left + 1));
        
    /* if unbalanced sub-arrays, change pivot selection strategy */
    if (Ratio < 0.2)
    {
        Choose_Avg = !Choose_Avg;
    }

    if (Pivot != Smallest) /* if values in the Left sub-array are not identical */
    {   
        QuickSort4_Float_ASC_Impl(Data, Left, Bound - 1, Choose_Avg, Average(Smallest, Pivot), RemainingLevels - 1);
    }
            
    if (Pivot + 1 != Biggest) /* if values in the Right sub-array are not identical */
    {   
        QuickSort4_Float_ASC_Impl(Data, Bound, Right, Choose_Avg, Average(Biggest, Pivot), RemainingLevels - 1);
    }
}

inline uniform float GetPivot4_Float_DESC(uniform float Data[], uniform uint32 Left, uniform uint32 Right)
{
    GetPivot4(float, Data, Left, Right, COEX_4_DESC, COEX_SHUFFLE_4_DESC);
}

inline uniform uint32 Partition_Vec_4_Float_DESC(uniform float CurVec[], uniform float PivotVec[], uniform float SmallestVec[], uniform float BiggestVec[])
{
    Partition_Vec_4(float, CurVec, PivotVec, SmallestVec, BiggestVec, max, min, <)
}

inline uniform uint32 Partition_Vectorized_4_Float_DESC(uniform float Data[], uniform uint32 Left, uniform uint32 Right, uniform float Pivot, uniform float& Smallest, uniform float& Biggest)
{
    Partition_Vectorized_4(float, Data, Left, Right, Pivot, Smallest, Biggest, max, min, <, Partition_Vec_4_Float_DESC);
}

inline uniform uint32 Partition_Vectorized_32_Float_DESC(uniform float Data[], uniform uint32 Left, uniform uint32 Right, uniform float Pivot, uniform float& Smallest, uniform float& Biggest)
{
    Partition_Vectorized_32(float, Data, Left, Right, Pivot, Smallest, Biggest, max, min, <, Partition_Vectorized_4_Float_DESC, Partition_Vec_4_Float_DESC);
}

void QuickSort4_Float_DESC_NR(uniform float Data[], uniform uint32 InLeft, uniform uint32 InRight, uniform float MaxValue, 
    uniform float MinValue, uniform bool Choose_Avg, uniform float InAvg)
{
    QuickSort4_NR(float, Data, InLeft, InRight, MaxValue, MinValue, Choose_Avg, InAvg, COEX_4_DESC, COEX_SHUFFLE_4_DESC, GetPivot4_Float_DESC, Partition_Vectorized_32_Float_DESC);
}

inline void QuickSort4_Float_DESC_Impl(uniform float Data[], uniform uint32 Left, uniform uint32 Right, 
    uniform bool Choose_Avg = false, uniform float Avg = 0, uniform int16 RemainingLevels = 40)
{
    if (Right - Left < 257)
    {
        /* use sorting networks for small arrays */
        uniform float Buffer[260]; /* buffer for sorting networks */
        uniform float* DataLeft = Data + Left;
        uniform uint32 DataSize = Right - Left + 1;
        Sort4_Sorting_Network_Impl(float, DataLeft, DataSize, Buffer, MIN_flt, COEX_4_DESC, COEX_SHUFFLE_4_DESC);
        return;
    }

    if (RemainingLevels <= 0)
    {
        QuickSort4_Float_DESC_NR(Data, Left, Right, MIN_flt, MAX_flt, Choose_Avg, Avg);
        return;
    }

    /* avg is average of largest and smallest values in array */
    uniform float Pivot = Choose_Avg ? Avg : GetPivot4_Float_DESC(Data, Left, Right);

    uniform float Smallest = MIN_flt;  /* smallest value after partitioning */ 
    uniform float Biggest = MAX_flt;   /* largest value after partitioning */
    
    uniform uint32 Bound = Partition_Vectorized_32_Float_DESC(Data, Left, Right + 1, Pivot, Smallest, Biggest);

    /* the ratio of the length of the smaller partition to the array length */
    uniform double Ratio = (min(Right - (Bound - 1), Bound - Left) / (uniform double)(Right - Left + 1));
        
    /* if unbalanced sub-arrays, change pivot selection strategy */
    if (Ratio < 0.2)
    {
        Choose_Avg = !Choose_Avg;
    }

    if (Pivot != Smallest) /* if values in the Left sub-array are not identical */
    {   
        QuickSort4_Float_DESC_Impl(Data, Left, Bound - 1, Choose_Avg, Average(Smallest, Pivot), RemainingLevels - 1);
    }
            
    if (Pivot + 1 != Biggest) /* if values in the Right sub-array are not identical */
    {   
        QuickSort4_Float_DESC_Impl(Data, Bound, Right, Choose_Avg, Average(Biggest, Pivot), RemainingLevels - 1);
    }
}

//====================================================================================================== float end

#endif